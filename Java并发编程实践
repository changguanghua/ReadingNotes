第2章 线程安全性
==
Java中的主要同步机制
--
- `synchronized`：提供了一种独占的加锁方式
- `volatile`类型变量
- 显式锁（Explicit Lock）
- 原子变量

__同步机制__涉及到两个方面：
- 原子性
- 可见性

- `synchronized`加锁机制可确保可见性和原子性(在李林峰的文档里还提到了__顺序性__)
- `volatile`类型变量只能确保可见性。(P32)
> 例如`volatile`的语义不足以确保递增操作的原子性。

__何时需要同步？__

_多个线程_访问_同一个_ __可变的__ 状态变量时。

三种方式解决_多个线程_访问_同一个_ __可变的__状态变量时程序出错的情况：
(前两种是对变量的处理，避免使用同步)
- 不在线程间共享该状态变量（__不共享__）
- 将状态变量改为__不可变__的变量（__不可变对象__一定是线程安全的，P38）
> 满足以下条件时对象才是不可变的:(P38)
> - 对象创建以后其状态就不能修改。
> - 对象的所有域都是`final`类型。
> - 对象是正确创建的（在对象的创建期间，`this`引用没有__逸出__）
- 在访问状态变量时使用__同步__。

原子性
--
###竞态条件（Race Condition）###

在并发编程中，由于不恰当的执行时序而出现不正确的结果。（P15）

当某个计算的正确性取决于多个线程的交替执行时序时，就会发生竞态条件。

竞态条件的_类型_：
- （1）先检查后执行（check-and-act）
- （2）读取-修改-写入。

竞态条件的_本质_：基于一种可能失效的观察结果来做出判断或者执行某个操作。

第3章 对象的共享
==
__Java的内存模型__
![Alt text](data:image,local://1392540191805)

__Java内存交互协议__

__Java的内存模型__定义了8种操作完成主内存和工作内存的变量访问：
- `lock`：_主内存变量_，把一个变量标识为某个线程独占的状态
- `unlock`：_主内存变量_，把一个处于锁定状态变量释放出来，被释放后的变量
才可以被其它线程锁定
- `read`：_主内存变量_，把一个变量的值从主内存传输到线程的工作内存中，以
便随后的load动作使用
- `load`：_工作内存变量_，把read读取到的主内存中的变量值放入工作内存的
变量拷贝中
- `use`：_工作内存变量_，把工作内存中变量的值传递给java虚拟机执行引擎，
每当虚拟机遇到一个需要使用到变量值的字节码指令时将会执行该操作
- `assign`：_工作内存变量_，把从执行引擎接收到的变量的值赋值给工作变量，
每当虚拟机遇到一个给变量赋值的字节码时将会执行该操作
- `store`：_工作内存变量_，把工作内存中一个变量的值传送到主内存中，以便
随后的write操作使用
- `write`：_主内存变量_，把store操作从工作内存中得到的变量值放入主内存
的变量中。

![Alt text](data:image,local://1392540390710)
`volatile`关键字的作用：
- 当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是__共享__的，因此不会将该变量上的操作与其他内存操作一起__重排序__
- `volatile`变量不会被缓存在_寄存器_或者_对其他处理器不可见的地方_。（但是会缓存在CPU Cache中）。

因此在读取`volatile`变量时总是会返回最新写入的值。

访问`volatile`变量是不会执行加锁操作，因此也就不会使线程阻塞。（比`synchronized`更轻量级的同步机制。）

从内存可见性角度来看，写入`volatile`变量相当于退出同步代码块，读取`volatile`变量相当于进入同步代码块。

__何时才应该使用`volatile`变量？__
+ 当变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
+ 该变量不会与其他变量一起纳入__不变性条件__。
+ 在访问变量时不需要加锁。

__发布和逸出__

`发布`一个对象：使对象能够在当前作用域之外的代码中使用。
>- 将一个指向对象的引用保存到其他代码可以访问的地方。
>- 在某一个非私有的方法中返回该引用。
>- 将引用传递到其他类的方法中。
